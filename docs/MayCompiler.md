# MayRedstone Compiler

The goal of this project is to optimize redstone and process it on CUDA Kernel to speeds which are largely considered impossible by using compiler techniques inspired by LLVM.

# In-memory representation

Redstone circuits can be represented in a Grid to process it in parallel.

# Stages

The compilation progresss will be split into stages as follows

1. Generation of the weighted directed graph
2. Logic Optimization
3. Generation of intermediate representation (e.g LLVM IR)
4. Native code generation

## Generation of the weighted directed graph

Firstly, a list of all redstone components in area will need to be created. This can be done easily by iterating through all blocks in the region and checking if they are potential components. Each component will be a node.

The links can be found by running a breadth first search starting from each input of the components. The weight will the be distance between the two componenets in signal strength.

### Example

![Example In-Game](img/ex1.png)
![Example Graph](img/ex1-graph.png)

This is a real graph generated by the current MCHPRS redpiler implementation.
As you can see, each redstone wire is a leaf node. The weights represent the distance from the source of the power.

## Logic optimization

TODO

## Generation of intermediate representation

TODO

## Native Code generation

TODO

Each node will generate 2 functions: update and tick. Each node will have a global memory location holding their state.
Example of generated code in C form:
```c
struct State {
    // Information such as powered or output strength
}
struct State n0;
void n0_update() {
    // ...
}
void n0_tick() {
    // ...
}
```